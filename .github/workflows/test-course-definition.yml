# This workflow is invoked by course repositories to test course definitions.
name: Test Course Definition

on:
  workflow_call:
    inputs:
      sdkRef:
        required: false
        type: string
        default: main

jobs:
  verify_templates_compiled:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    timeout-minutes: 5

    steps:
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.2.2 # Error: 1.2.3 breaks course-sdk as of 2025-02-27

      - uses: actions/checkout@v3
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{inputs.sdkRef}}

      - uses: actions/checkout@v3
        with:
          path: courses/${{github.event.repository.name}}

      # - uses: depot/setup-action@v1
      # - uses: depot/build-push-action@v1
      #   with:
      #     project: tsp80qbtxw
      #     context: .
      #     load: true
      #     tags: tester:depot

      - run: bun install
      - run: make install

      - run: course-sdk compile
        working-directory: courses/${{github.event.repository.name}}

      - name: "Ensure no uncommitted changes to compiled templates"
        run: git diff --exit-code
        working-directory: courses/${{github.event.repository.name}}

      - name: "Print untracked files"
        run: git ls-files compiled_starters/ --exclude-standard --others
        working-directory: courses/${{github.event.repository.name}}

      - name: "Ensure untracked files are empty (check previous step for list of files)"
        run: test -z "$(git ls-files compiled_starters/ --exclude-standard --others)"
        working-directory: courses/${{github.event.repository.name}}

  lint:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    timeout-minutes: 5

    steps:
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.2.2 # Error: 1.2.3 breaks course-sdk as of 2025-02-27

      - uses: actions/checkout@v3
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{inputs.sdkRef}}

      - uses: actions/checkout@v3
        with:
          path: courses/${{github.event.repository.name}}

      - run: bun install
      - run: make install

      - name: "Lint using course-sdk"
        run: course-sdk lint
        working-directory: courses/${{github.event.repository.name}}

  identify_language_slugs:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    outputs:
      language_slugs: ${{ steps.generate-language-slugs.outputs.language_slugs }}

    steps:
      - uses: actions/checkout@v3

      - name: Generate Language Slugs
        id: generate-language-slugs
        run: |-
          LANGUAGE_SLUGS=$(ls solutions | jq -Rnc '[inputs]')
          echo ::set-output name=language_slugs::${LANGUAGE_SLUGS}

  test:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    timeout-minutes: 20

    needs:
      - identify_language_slugs

    strategy:
      matrix:
        language: ${{ fromJSON(needs.identify_language_slugs.outputs.language_slugs) }}

    steps:
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.2.2 # Error: 1.2.3 breaks course-sdk as of 2025-02-27

      - uses: actions/checkout@v3
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{inputs.sdkRef}}

      - run: bun install
      - run: make install

      - uses: actions/checkout@v3
        with:
          path: courses/${{github.event.repository.name}}

      - run: "echo ::remove-matcher owner=go::" # Messes with our output

      # - uses: depot/setup-action@v1
      # - uses: depot/build-push-action@v1
      #   with:
      #     project: tsp80qbtxw
      #     context: .
      #     load: true
      #     tags: tester:depot

      - run: git config --global user.email "hello@codecrafters.io"
      - run: git config --global user.name "codecrafters-bot"

      - run: course-sdk test ${{matrix.language}}
        working-directory: courses/${{github.event.repository.name}}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  validate-schemas:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v3
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{inputs.sdkRef}}

      - uses: actions/checkout@v3
        with:
          path: courses/${{github.event.repository.name}}

      # - uses: depot/setup-action@v1
      # - uses: depot/build-push-action@v1
      #   with:
      #     project: tsp80qbtxw
      #     context: .
      #     load: true
      #     tags: js-tools

      - run: docker compose run js-tools ajv validate --spec draft2020 -s schemas/course-definition.json -d courses/${{github.event.repository.name}}/course-definition.yml

  validate-stages-naming:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v3
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{inputs.sdkRef}}

      - uses: actions/checkout@v3
        with:
          path: courses/${{github.event.repository.name}}

      - run: scripts/validate_stages_naming.sh "courses/${{github.event.repository.name}}"

  test_stage_descriptions:
    name: test_stage_descriptions
    runs-on: ubuntu-latest
    timeout-minutes: 20

    # Avoid leaking secrets to forked PRs
    if: github.event.pull_request.head.repo.fork == false

    permissions:
      contents: read
      pull-requests: write
      checks: write

    steps:
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: 1.2.2

      # Checkout course-sdk (keeps paths consistent with other jobs)
      - uses: actions/checkout@v4
        with:
          repository: "codecrafters-io/course-sdk"
          ref: ${{ inputs.sdkRef }}

      # Checkout the course repo (the PR target)
      - uses: actions/checkout@v4
        with:
          path: courses/${{ github.event.repository.name }}
          ref: ${{ github.sha }}   # PR merge commit for pull_request jobs
          fetch-depth: 0           # full history avoids future surprises

      # Checkout the private LLM rules runner (use a PAT or GitHub App token)
      - name: Checkout llm-rules runner
        uses: actions/checkout@v4
        with:
          repository: codecrafters-io/llm-rules-test
          ref: master
          path: tools/llm-linter
          token: ${{ secrets.LLM_LINTER_TOKEN }}

      - name: Install linter deps
        working-directory: tools/llm-linter
        run: bun install

      # (Optional) limit to changed files only. Comment this block out to lint all files.
      - name: Compute target stage files
        id: targets
        shell: bash
        working-directory: courses/${{ github.event.repository.name }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
      
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR=${{ github.event.pull_request.number }}
            OWNER_REPO="${{ github.repository }}"
            files=()
            page=1
            while :; do
              resp="$(curl -sS -H "Authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${OWNER_REPO}/pulls/${PR}/files?per_page=100&page=$page")"
              page_files="$(echo "$resp" | jq -r '.[].filename')"
              [[ -z "$page_files" ]] && break
              while IFS= read -r f; do [[ -n "$f" ]] && files+=("$f"); done <<< "$page_files"
              (( ${#files[@]} < 100*page )) && break
              ((page++))
            done
      
            targets=()
            for f in "${files[@]}"; do
              [[ "$f" == stage_descriptions/*.md || "$f" == stage_descriptions/**/*.md ]] && targets+=("$f")
            done
      
            if ((${#targets[@]} == 0)); then
              echo "none=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
      
            # ABSOLUTE paths (no more ../ ambiguity)
            abs=()
            for f in "${targets[@]}"; do
              abs+=( "$GITHUB_WORKSPACE/courses/${{ github.event.repository.name }}/$f" )
            done
            printf '%s\0' "${abs[@]}" > "$GITHUB_WORKSPACE/targets.zlist"
            echo "none=false" >> "$GITHUB_OUTPUT"
            echo "zlist=$GITHUB_WORKSPACE/targets.zlist" >> "$GITHUB_OUTPUT"
            exit 0
          fi
      
          # Non-PR fallback: expand glob locally and make absolute
          shopt -s globstar nullglob
          files=( stage_descriptions/**/*.md stage_descriptions/*.md )
          if ((${#files[@]} == 0)); then
            echo "none=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
      
          abs=()
          for f in "${files[@]}"; do
            abs+=( "$GITHUB_WORKSPACE/courses/${{ github.event.repository.name }}/$f" )
          done
          printf '%s\0' "${abs[@]}" > "$GITHUB_WORKSPACE/targets.zlist"
          echo "none=false" >> "$GITHUB_OUTPUT"
          echo "zlist=$GITHUB_WORKSPACE/targets.zlist" >> "$GITHUB_OUTPUT"

      - name: Run LLM rules (changed files)
        if: steps.targets.outputs.none == 'false'
        working-directory: tools/llm-linter
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          LLM_LINT_MODEL: gpt-5
        shell: bash
        run: |
          set -euo pipefail
          mapfile -d '' files < "${{ steps.targets.outputs.zlist }}"
          mkdir -p reports
          
          set +e
          bun run src/index.ts \
            --format html \
            --out reports/llm-lint \
            --report reports/lint.json \
            --include-source \
            "${files[@]}"
              code=$?
            set -e
            echo "exitcode=$code" >> "$GITHUB_OUTPUT"

      # Convert the JSON summary to JUnit XML for GitHub annotations/checks
      - name: Convert JSON → JUnit XML
        working-directory: tools/llm-linter
        run: |
          set -euo pipefail
          if [[ ! -f reports/lint.json ]]; then
            echo "No reports/lint.json found; skipping JUnit conversion."
            exit 0
          fi
      
          bun --eval '
            import { readFileSync, writeFileSync } from "node:fs";
            const data = JSON.parse(readFileSync("reports/lint.json", "utf8"));
            const REPO_ROOT = process.env.REPO_ROOT?.replace(/\\/g,"/") || "";
            const esc = (s) => String(s)
              .replace(/&/g,"&amp;")
              .replace(/</g,"&lt;")
              .replace(/>/g,"&gt;")
              .replace(/"/g,"&quot;");
      
            const toRepoRel = (absOrRel) => {
              let p = String(absOrRel).replace(/\\/g,"/");
              // If it starts with the checked-out course path, strip it:
              if (REPO_ROOT && p.startsWith(REPO_ROOT + "/")) {
                p = p.slice(REPO_ROOT.length + 1);
              }
              // If it still starts with "./", trim it
              if (p.startsWith("./")) p = p.slice(2);
              return p;
            };
      
            // Find first line (1-based) of q within src; if not found, return 1
            function findLine(src, q) {
              if (!src || !q) return 1;
              // Try exact, then a loosened version (collapse whitespace)
              let idx = src.indexOf(q);
              if (idx === -1) {
                const space = (s) => s.replace(/\s+/g," ").trim();
                const s1 = space(src);
                const q1 = space(q);
                idx = s1.indexOf(q1);
                if (idx === -1) return 1;
                // Map back to original: best-effort – fall back to 1 if complicated
                // (Simplify: return 1 for this path to avoid misreporting)
                return 1;
              }
              const pre = src.slice(0, idx);
              const line = pre.split(/\r?\n/).length;
              return Math.max(1, line);
            }
      
            const testCount = data.files.reduce((a,f)=>a + f.rules.length, 0);
            const failCount = data.files.reduce((a,f)=>a + f.rules.filter(r=>!r.pass).length, 0);
      
            const suites = data.files.map((f) => {
              const fileRepoRel = toRepoRel(f.file);
              const src = f.source || "";
              const tests = f.rules.length;
              const failures = f.rules.filter(r=>!r.pass).length;
      
              const cases = f.rules.map((r) => {
                const name = r.id;
                // Derive a line if we can
                let line = 1;
                if (!r.pass) {
                  // Look for an object with "quote" in suggested_fixes
                  if (Array.isArray(r.suggested_fixes)) {
                    for (const fx of r.suggested_fixes) {
                      if (fx && typeof fx === "object" && fx.quote && typeof fx.quote === "string") {
                        line = findLine(src, fx.quote);
                        break;
                      }
                    }
                  }
                }
                if (r.pass) {
                  return `<testcase name="${esc(name)}" classname="${esc(fileRepoRel)}" file="${esc(fileRepoRel)}" line="${line}"></testcase>`;
                } else {
                  const msg = r.rationale ? esc(r.rationale) : "Failed rule";
                  const fixes = Array.isArray(r.suggested_fixes) && r.suggested_fixes.length
                    ? r.suggested_fixes.slice(0,5).map((x) => {
                        if (typeof x === "string") return `- ${x}`;
                        const t = x.type ? `[${x.type}] ` : "";
                        const q = x.quote ? `quote: "${x.quote}"` : "";
                        const repl = x.replacement ? ` -> ${x.replacement}` : "";
                        return `- ${t}${q}${repl}`.trim();
                      }).join("\n")
                    : "";
                  const body = (r.rationale ? `rationale: ${r.rationale}\n` : "") + (fixes ? `suggested fixes:\n${fixes}\n` : "");
                  return `<testcase name="${esc(name)}" classname="${esc(fileRepoRel)}" file="${esc(fileRepoRel)}" line="${line}">
                  <failure message="${msg}">${esc(body)}</failure>
                </testcase>`;
                }
              }).join("\n");
      
              return `<testsuite name="${esc(fileRepoRel)}" tests="${tests}" failures="${failures}">
                ${cases}
              </testsuite>`;
              }).join("\n");
      
            const xml = `<?xml version="1.0" encoding="UTF-8"?>
                <testsuites name="llm-doc-linter" tests="${testCount}" failures="${failCount}">
                  ${suites}
                </testsuites>
              `;
            writeFileSync("reports/junit.xml", xml, "utf8");
            console.log("Wrote JUnit to reports/junit.xml");
          '

      - name: Upload JUnit XML
        uses: actions/upload-artifact@v4
        with:
          name: llm-lint-junit
          path: tools/llm-linter/reports/junit.xml

      # Publish test results as a Check + PR annotations
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2.20.0
        with:
          files: tools/llm-linter/reports/junit.xml
          check_name: "LLM Doc Lint"
          report_individual_runs: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

